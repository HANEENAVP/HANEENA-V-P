# -*- coding: utf-8 -*-
"""INTERNSHIP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_a22beqUOxxm1fTPZYZS5YgFHAMrqBd-
"""

#import the libraries

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

#import the dataset

data=pd.read_csv(r'/content/credit.csv')
data

data.shape

data.columns

data.info()

#the statistics

data.describe()

#checking the null values

data.isnull().sum()

#to find the duplicated rows

data[data.duplicated(keep='first')]

#arranging numerical and categorical columns

numeric_cols= data.select_dtypes(exclude='object').columns
cat_cols= data.select_dtypes(include='object').columns

numeric_cols

cat_cols

credit_cal=data.select_dtypes(include='object')
credit_num=data.select_dtypes(include='number')

credit_cal

credit_num

#Data visualisation

"""EDA"""

#Histplot of credit_score

plt.figure(figsize=(12,6))

plt.subplot(1,2,1)
sns.histplot(data['Credit_Score'],bins=30,kde=True,color='blue')
plt.show()

corr_format= credit_num.corr()
corr_format

#correlation Analysis
correlation_matrix = corr_format.corr()
sns.heatmap(correlation_matrix, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()



# Pairplot for Numerical Variables

sns.pairplot(credit_num)
plt.suptitle('Pairplot of Numerical Variables', y=1.02)

#count plot of categorical variable(credit_score)
sns.countplot(x='Credit_Score',data=data)
plt.title('credit_score distribution')

"""DEMOGRAPHIC ANALYSIS"""

#histplot of credict score by occupation

plt.figure(figsize=(14,7))
sns.histplot(hue='Occupation',x='Credit_Score',data=data ,bins=30, kde=True)
plt.title('Credit_Score by occupation level')
plt.tight_layout()
plt.show()



#boxplot of credit score by Annual income

plt.figure(figsize=(14,7))
sns.boxplot(x='Annual_Income',y='Credit_Score',data=data,palette='viridis')
plt.title('Credit_Score by Annual_Income')

data.columns

"""DEBT ANALYSIS"""

# Scatter plot for Outstanding Debts vs. Credit Scores
sns.scatterplot(x='Outstanding_Debt', y='Credit_Score', data=data, alpha=0.7, color='green')
plt.title('Outstanding Debts vs. Credit Scores')
plt.xlabel('Outstanding Debts')
plt.ylabel('Credit Score')

# Scatter plot for Credit Utilization Ratio vs. Credit Scores
plt.subplot(1, 2, 1)
sns.scatterplot(x='Credit_Utilization_Ratio', y='Credit_Score', data=data, alpha=0.7, color='blue')
plt.title('Credit Utilization Ratio vs. Credit Scores')
plt.xlabel('Credit Utilization (monthly Balance / changed Credit Limit)')
plt.ylabel('Credit Score')



"""PAYMENT ANALYSIS"""

# Box plot for Late Payments vs. Credit Scores
sns.boxplot(x='Num_of_Delayed_Payment', y='Credit_Score', data=data, palette='Blues')
plt.title('Delayed Payments vs. Credit Scores')
plt.xlabel('Number of Delayed Payments')
plt.ylabel('Credit Score')



data.head()

#drop unwanted columns

data.drop(['ID','Customer_ID','Month','Name','SSN','Type_of_Loan','Credit_History_Age','Monthly_Inhand_Salary'],axis=1,inplace=True)

data.head()

"""ENCODING"""

#obtaining their counts

data['Credit_Mix'].value_counts()

data['Occupation'].value_counts()

data['Payment_of_Min_Amount'].value_counts()

data['Payment_Behaviour'].value_counts()

from sklearn.preprocessing import LabelEncoder

le=LabelEncoder()

data['Occupation_encoded']=le.fit_transform(data['Occupation'])

data['Credit_Mix_encoded']=le.fit_transform(data['Credit_Mix'])

data['Payment_of_Min_Amount_encoded']=le.fit_transform(data['Payment_of_Min_Amount'])

data['Payment_Behaviour_encoded']=le.fit_transform(data['Payment_Behaviour'])

print(data)

data.head()

data.columns

#remove the main encoded columns

data.drop(['Occupation','Credit_Mix','Payment_of_Min_Amount','Payment_Behaviour'],axis=1,inplace=True)
data.head()

"""SPLITTING DATASET"""

X=data.drop(['Credit_Score'],axis=1)
y=data['Credit_Score']



"""STANDARDISING"""

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X = scaler.fit_transform(X)

from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.20,random_state=42)



